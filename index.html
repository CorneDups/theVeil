<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>theVeilJourney</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">
  <!-- Three.js and GSAP from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
  <style>
    /* ======================
       Toggle Button Style
       ====================== */
    #toggle-anim {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 100;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      background-color: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s, opacity 0.3s;
    }
    #toggle-anim:hover {
      background-color: rgba(255, 255, 255, 0.9);
    }
    
    /* ======================
       Three.js & Particle Canvas Styles
       ====================== */
    #three-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -3;
      pointer-events: none;
    }
    #particle-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -2;
      pointer-events: none;
    }
    
    /* ======================
       Audio Visualization Styles
       ====================== */
    #audio-visualization {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
      pointer-events: none;
      opacity: 0.4;
    }
    
    /* ======================
       Special Animation Overlay Styles
       ====================== */
    #special-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 50;
      display: none;
      overflow: hidden;
    }
    /* The shine element that will animate diagonally */
    #special-overlay .shine {
      position: absolute;
      width: 200%;
      height: 200px;
      background: linear-gradient(90deg, 
        transparent,
        rgba(255,0,0,0.5),
        rgba(255,165,0,0.5),
        rgba(255,255,0,0.5),
        rgba(0,255,0,0.5),
        rgba(0,0,255,0.5),
        rgba(128,0,128,0.5),
        transparent
      );
      filter: blur(20px);
      transform-origin: center;
      opacity: 0;
    }
    
    /* Sparkle elements */
    #special-overlay .sparkle {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: white;
      border-radius: 50%;
      opacity: 0;
      filter: blur(1px);
      transform: scale(0);
      box-shadow: 
        0 0 10px 2px rgba(255,255,255,0.8),
        0 0 20px 5px rgba(255,215,0,0.6);
    }

    /* ======================
       Keyframe Animations
       ====================== */
    @keyframes breeze { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes shadowPulse { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(0.4); } }
    @keyframes fireFlicker { 0% { filter: brightness(1); } 25% { filter: brightness(1.3); } 50% { filter: brightness(0.8); } 75% { filter: brightness(1.3); } 100% { filter: brightness(1); } }
    @keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-4px, 4px); } 40% { transform: translate(4px, -4px); } 60% { transform: translate(-4px, -4px); } 80% { transform: translate(4px, 4px); } 100% { transform: translate(0); } }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
    @keyframes fall { 0% { background-position: 0 -100px; } 100% { background-position: 0 100px; } }
    @keyframes wander { 0% { background-position: 0 0; } 100% { background-position: 100% 0; } }
    @keyframes dawn { 0% { background-position: 0 0; } 50% { background-position: 50% 50%; } 100% { background-position: 0 0; } }
    @keyframes celestial { 0% { opacity: 0; transform: scale(0.95); } 100% { opacity: 1; transform: scale(1); } }
    @keyframes wildernessFade { 0%, 80% { opacity: 0; } 85% { opacity: 0.5; } 90% { opacity: 0.7; } 95% { opacity: 0.9; } 100% { opacity: 0; } }
    
    /* ======================
       Prologue Styles
       ====================== */
    #prologue-container {
      text-align: center;
      margin-bottom: 20px;
      font-family: 'Cinzel', serif;
      color: rgba(0, 0, 0, 0.9);
      z-index: 3;
      position: relative;
      background-color: rgba(255, 255, 255, 0.6);
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(2px);
      max-width: 80%;
      margin-left: auto;
      margin-right: auto;
    }
    #prologue-container .prologue-title {
      font-size: 24px;
      margin-bottom: 10px;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
    }
    #prologue-container .prologue-icon {
      display: inline-block;
      cursor: pointer;
      opacity: 0.85;
      transition: opacity 0.2s, transform 0.2s;
    }
    #prologue-container .prologue-icon:hover {
      opacity: 1;
      transform: scale(1.1);
    }
    #prologue-container .prologue-icon img {
      width: 40px;
      height: 40px;
      background: transparent;
      border-radius: 50%;
    }
    
    /* ======================
       Body and Section Styles
       ====================== */
    body.default-style { background-color: #f0f0f0; color: #000; }
    body.style-section-1 { background: linear-gradient(135deg, #111, #444); background-size: 200% 200%; animation: breeze 15s ease-in-out infinite; font-family: 'Times New Roman', serif; }
    body.style-section-2 { background: linear-gradient(135deg, #550000, #ff6600); background-size: 200% 200%; animation: flicker 1s infinite alternate; color: #fff; }
    body.style-section-3 { background: #000; animation: shadowPulse 10s infinite alternate; color: #fff; }
    body.style-section-4 { background: linear-gradient(135deg, #ff0000, #fff700, #ffd700); background-size: 200% 200%; animation: fireFlicker 4s infinite; color: #000; }
    body.style-section-5 { background: linear-gradient(135deg, #000, #330033); animation: glitch 8s infinite; color: #fff; }
    body.style-section-6 { background: linear-gradient(135deg, #000080, #ffd700); animation: pulse 12s infinite; color: #fff; }
    body.style-section-7 { background: #333; background-size: 100% auto; animation: fall 20s linear infinite; color: #fff; }
    body.style-section-8 { background: url('images/wilderness-bg.jpg'); background-size: cover; animation: wander 3s linear infinite; color: #fff; position: relative; }
    body.style-section-8::after { content: ""; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; pointer-events: none; opacity: 0; animation: wildernessFade 3.2s ease-in-out infinite; z-index: 1; }
    body.style-section-9 { background: linear-gradient(135deg, #001f3f, #ffcc00); background-size: 200% 200%; animation: dawn 20s ease-in-out infinite; color: #fff; }
    body.style-section-10 { background: #f0e68c; animation: celestial 33s ease-out forwards; color: #000; }
    
    /* ======================
       General Layout & UI Elements
       ====================== */
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; transition: background 0.5s, color 0.5s; position: relative; z-index: 2; }
    #main-wrapper { display: flex; align-items: flex-start; justify-content: center; gap: 20px; flex-wrap: wrap; width: 100%; padding: 20px; box-sizing: border-box; position: relative; z-index: 3; }
    .circle-container { position: relative; width: 500px; height: 500px; margin-bottom: 20px; }
    .circle { position: absolute; width: 100%; height: 100%; border-radius: 50%; }
    #center-image { 
      position: absolute; 
      top: 51%;
      left: 50%; 
      width: 200px; 
      height: 200px; 
      margin-top: -100px; 
      margin-left: -100px; 
      border-radius: 50%; 
      overflow: hidden; 
      border: 2px solid rgba(204, 204, 204, 0.7); 
      background-color: rgba(255, 255, 255, 0.8);
      z-index: 10;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      transition: opacity 0.3s;
    }
    #center-image img { 
      width: 100%; 
      height: 100%; 
      object-fit: cover;
      opacity: 0.9;
    }
    .section { 
      position: absolute; 
      top: 55%; 
      left: 50%; 
      width: 100px; 
      height: 100px; 
      margin: -50px; 
      text-align: center; 
      border: 2px solid rgba(255, 255, 255, 0.3); 
      border-radius: 50%; 
      transition: border-color 0.3s, background-color 0.3s; 
      z-index: 5;
      background-color: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(1px);
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.1);
    }
    .section.active { 
      border-color: rgba(0, 0, 139, 0.8); 
      background-color: rgba(255, 255, 0, 0.3); 
    }
    .section .section-text { 
      margin-bottom: 5px;
      text-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
    }
    .section .episode-name { 
      font-size: 12px; 
      font-weight: bold;
      color: rgba(0, 0, 0, 0.9);
    }
    .section .song-name { 
      font-size: 10px;
      color: rgba(0, 0, 0, 0.8);
    }
    .section .icons { 
      display: flex; 
      justify-content: center; 
      gap: 5px;
    }
    .section .icons img { 
      width: 24px; 
      height: 24px; 
      cursor: pointer; 
      background: transparent;
      opacity: 0.85;
      transition: opacity 0.2s, transform 0.2s;
    }
    .section .icons img:hover {
      opacity: 1;
      transform: scale(1.1);
    }
    #text-container { 
      width: 300px; 
      max-height: 500px; 
      overflow-y: auto; 
      padding: 10px; 
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(204, 204, 204, 0.5); 
      border-radius: 5px; 
      font-size: 14px; 
      line-height: 1.5; 
      color: rgba(0, 0, 0, 0.9);
      position: relative; 
      z-index: 4; 
      white-space: pre-wrap;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(2px);
      transition: background 0.3s, opacity 0.3s;
    }
    #audio-player { 
      margin-top: 20px; 
      position: relative; 
      z-index: 3;
      opacity: 0.85;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      background-color: rgba(255, 255, 255, 0.3);
      transition: opacity 0.3s;
    }
    #audio-player:hover {
      opacity: 1;
    }
    @media (max-width: 600px) {
      .circle-container { width: 300px; height: 300px; }
      #center-image { width: 120px; height: 120px; margin-top: -60px; margin-left: -60px; }
      .section { width: 60px; height: 60px; margin: -30px; }
      .section .episode-name { font-size: 10px; }
      .section .song-name { font-size: 8px; }
      .section .icons img { width: 16px; height: 16px; }
      #text-container { width: 250px; }
    }
  </style>
</head>
<body class="default-style">
  <!-- Toggle Animations Button -->
  <button id="toggle-anim" onclick="APP.toggleAnimations()">Anim Off</button>
  
  <!-- Three.js Container for 3D Graphics -->
  <div id="three-container"></div>
  <!-- Particle Canvas -->
  <canvas id="particle-canvas"></canvas>
  <!-- Audio Visualization Canvas -->
  <canvas id="audio-visualization"></canvas>
  
  <!-- Prologue Container -->
  <div id="prologue-container">
    <p class="prologue-title">Prologue - Piercing the Veil</p>
    <div class="prologue-icon" onclick="APP.handlePrologue()">
      <img src="images/audio-note.jpg" alt="Prologue Audiobook">
    </div>
  </div>
  
  <!-- Main Interactive Area -->
  <div id="main-wrapper">
    <div class="circle-container">
      <div class="circle" id="circle">
        <!-- Section 1 (Unknown) -->
        <div class="section" id="section-1" style="transform: rotate(-72deg) translate(200px) rotate(72deg);">
          <div class="section-text">
            <div class="episode-name">Part 1-2</div>
            <div class="song-name">Unknown</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(1, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(1, 'song')">
          </div>
        </div>
        <!-- Section 2 (Ashes) -->
        <div class="section" id="section-2" style="transform: rotate(-36deg) translate(200px) rotate(36deg);">
          <div class="section-text">
            <div class="episode-name">Part 3-4</div>
            <div class="song-name">Ashes</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(2, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(2, 'song')">
          </div>
        </div>
        <!-- Section 3 (Shadow) -->
        <div class="section" id="section-3" style="transform: rotate(0deg) translate(200px) rotate(0deg);">
          <div class="section-text">
            <div class="episode-name">Part 5</div>
            <div class="song-name">Shadow</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(3, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(3, 'song')">
          </div>
        </div>
        <!-- Section 4 (Fire & Blood) -->
        <div class="section" id="section-4" style="transform: rotate(36deg) translate(200px) rotate(-36deg);">
          <div class="section-text">
            <div class="episode-name">Part 6</div>
            <div class="song-name">Fire & Blood</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(4, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(4, 'song')">
          </div>
        </div>
        <!-- Section 5 (Void) -->
        <div class="section" id="section-5" style="transform: rotate(72deg) translate(200px) rotate(-72deg);">
          <div class="section-text">
            <div class="episode-name">Part 7</div>
            <div class="song-name">Void</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(5, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(5, 'song')">
          </div>
        </div>
        <!-- Section 6 (Lion Roar) -->
        <div class="section" id="section-6" style="transform: rotate(108deg) translate(200px) rotate(-108deg);">
          <div class="section-text">
            <div class="episode-name">Part 8-10</div>
            <div class="song-name">Lion Roar</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(6, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(6, 'song')">
          </div>
        </div>
        <!-- Section 7 (Abyss) -->
        <div class="section" id="section-7" style="transform: rotate(144deg) translate(200px) rotate(-144deg);">
          <div class="section-text">
            <div class="episode-name">Part 9-10</div>
            <div class="song-name">Abyss</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(7, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(7, 'song')">
          </div>
        </div>
        <!-- Section 8 (Wilderness) -->
        <div class="section" id="section-8" style="transform: rotate(180deg) translate(200px) rotate(-180deg);">
          <div class="section-text">
            <div class="episode-name">Part 11-12</div>
            <div class="song-name">Wilderness</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(8, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(8, 'song')">
          </div>
        </div>
        <!-- Section 9 (Dawn) -->
        <div class="section" id="section-9" style="transform: rotate(216deg) translate(200px) rotate(-216deg);">
          <div class="section-text">
            <div class="episode-name">Part 13</div>
            <div class="song-name">Dawn</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(9, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(9, 'song')">
          </div>
        </div>
        <!-- Section 10 (In Your Arms) -->
        <div class="section" id="section-10" style="transform: rotate(252deg) translate(200px) rotate(-252deg);">
          <div class="section-text">
            <div class="episode-name">Part 14</div>
            <div class="song-name">In Your arms</div>
          </div>
          <div class="icons">
            <img src="images/audio-note.jpg" alt="Audiobook" onclick="APP.handleAudioClick(10, 'audiobook')">
            <img src="images/music-note.jpg" alt="Song" onclick="APP.handleAudioClick(10, 'song')">
          </div>
        </div>
      </div>
      <div id="center-image">
        <img src="images/default-image.jpg" alt="Default Center">
      </div>
    </div>
    <div id="text-container">
      <p>Welcome, Thank you for visiting! To start, click on any of the note or audiobook symbols. Best place to start is with the prologue (above) and then Part 1-2. In each section there is an audio book and a song which roughly connects to that part of the journey. All the words to every audio piece will be displayed here (for audio+visual listeners like myself). May you enjoy this deeply personal journey of mine and maybe find something meaningful for yourself, by Grace. If you don't find it meaningful, that's also okay. I appreciate you giving it a chance.
With gratitude, 
Corné.</p>
    </div>
  </div>
  <!-- Updated audio element with controlsList and disabled right-click -->
  <audio id="audio-player" controls controlsList="nodownload" oncontextmenu="return false;">Your browser does not support the audio element.</audio>
  
  <!-- Special overlay for golden shine animation -->
  <div id="special-overlay"></div>
  
  <script>
  /**
   * Modular application architecture with performance optimizations
   */
  const APP = (function() {
    'use strict';
    
    // DOM Element Cache
    const DOM = {
      audioPlayer: document.getElementById('audio-player'),
      centerImage: document.querySelector('#center-image img'),
      textContainer: document.getElementById('text-container'),
      visualizationCanvas: document.getElementById('audio-visualization'),
      particleCanvas: document.getElementById('particle-canvas'),
      toggleButton: document.getElementById('toggle-anim'),
      specialOverlay: document.getElementById('special-overlay'),
      threeContainer: document.getElementById('three-container')
    };
    
    // Canvas contexts
    const CTX = {
      visual: DOM.visualizationCanvas.getContext('2d'),
      particle: DOM.particleCanvas.getContext('2d')
    };
    
    // App State
    const STATE = {
      audioContext: null,
      analyser: null,
      dataArray: null,
      audioInitialized: false,
      currentActive: null,
      lastSection: null,
      secondLastSection: null,
      freezeMotion: false,
      currentVisualizationStyle: 1,
      visualizationRunning: false,
      animationFrameId: null,
      spawnAccumulator: 0,
      lastTime: performance.now(),
      particles: [],
      bufferLength: 0,
      // Three.js related state
      three: {
        scene: null,
        camera: null,
        renderer: null,
        polyhedron: null,
        mainGroup: null,
        orbitSpheres: [],
        rotationSpeed: 0.005
      }
    };
    
    // Cached calculation values
    const CACHED = {
      // Precompute shuffled indices
      shuffledIndices: [],
      orbitFactorMap: {1: 1.0, 2: 1.2, 3: 0.8, 4: 1.5, 5: 1.3, 6: 1.1, 7: 1.6, 8: 1.0, 9: 0.9, 10: 1.0},
      // Special combinations dictionary
      specialCombinations: {
        "777": true, "003": true, "001": true, "002": true, "004": true, "006": true, 
        "008": true, "333": true, "111": true, "222": true, "888": true, "000": true, 
        "666": true, "999": true, "555": true, "444": true
      },
      // Precomputed color mappings for sections
      sectionColors: {
        1: { color1: '#333', color2: '#888', color3: '#666' },
        2: { color1: '#550000', color2: '#ff6600', color3: '#aa3300' },
        3: { color1: '#000', color2: '#777', color3: '#444' },
        4: { color1: '#770000', color2: '#ff0000', color3: '#aa0000' },
        5: { color1: '#330033', color2: '#990099', color3: '#660066' },
        6: { color1: '#000080', color2: '#ffd700', color3: '#8b4513' },
        7: { color1: '#000', color2: '#333', color3: '#666' },
        8: { color1: '#654321', color2: '#d2b48c', color3: '#8b4513' },
        9: { color1: '#001f3f', color2: '#ffcc00', color3: '#ff8c00' },
        10: { color1: '#ffb6c1', color2: '#f0e68c', color3: '#ffa07a' },
        default: { color1: '#000080', color2: '#00ffff', color3: '#0080ff' }
      },
      emitterColors: {
        1: "255,255,255",
        2: "255,69,0",
        3: "100,100,100",
        4: "255,0,0",
        5: "128,0,128",
        6: "255,215,0",
        7: "200,200,200",
        8: "210,180,140",
        9: "255,223,0",
        10: "255,192,203"
      },
      threeColors: {
        1: 0x222222, 
        2: 0xff4500, 
        3: 0x888888, 
        4: 0xff0000, 
        5: 0x800080,
        6: 0xffd700, 
        7: 0xc8c8c8, 
        8: 0xd2b48c, 
        9: 0xffdf00, 
        10: 0xffc0cb
      },
      rotationSpeeds: {
        1: -0.01, 
        2: 0.02, 
        3: 0.015, 
        4: 0.03, 
        5: 0.025,
        6: 0.02, 
        7: 0.035, 
        8: 0.02, 
        9: 0.015, 
        10: 0.01
      }
    };
    
    // Precompute shuffled indices for better performance
    function initShuffledIndices(count) {
      const indices = [];
      for (let i = 0; i < count; i++) {
        let index;
        if (i % 3 === 0) {
          index = Math.floor(i / 3);
        } else if (i % 3 === 1) {
          index = count - 1 - Math.floor(i / 3);
        } else {
          index = Math.floor(count / 2) + Math.floor(i / 6) - Math.floor(i / 3);
        }
        index = Math.max(0, Math.min(count - 1, index));
        indices.push(index);
      }
      return indices;
    }
    
    // Initialize frequency bands structure once
    const BANDS = {
      ranges: null,
      calculateRanges: function(dataLength) {
        this.ranges = {
          bass: { start: 0, end: Math.floor(dataLength * 0.1) },
          lowMid: { start: Math.floor(dataLength * 0.1), end: Math.floor(dataLength * 0.3) },
          highMid: { start: Math.floor(dataLength * 0.3), end: Math.floor(dataLength * 0.6) },
          treble: { start: Math.floor(dataLength * 0.6), end: dataLength }
        };
      }
    };
    
    /**
     * Particle class for efficient particle management
     */
    class Particle {
      constructor(x, y, vx, vy, life, color) {
        this.x = x; 
        this.y = y;
        this.vx = vx; 
        this.vy = vy;
        this.life = life; 
        this.remainingLife = life;
        this.color = color;
      }
      
      update(delta) {
        this.x += this.vx * delta;
        this.y += this.vy * delta;
        this.remainingLife -= delta;
        return this.remainingLife <= 0;
      }
      
      draw(ctx) {
        const alpha = Math.max(this.remainingLife / this.life, 0);
        ctx.fillStyle = `rgba(${this.color}, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    /**
     * Audio Context and Analyzer Setup
     */
    function initAudioContext() {
      try {
        if (!STATE.audioContext) {
          STATE.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // Resume context if suspended (needed for some browsers)
          if (STATE.audioContext.state === 'suspended') {
            STATE.audioContext.resume();
          }
          
          STATE.analyser = STATE.audioContext.createAnalyser();
          // Optimized FFT settings
          STATE.analyser.fftSize = 1024;
          STATE.analyser.smoothingTimeConstant = 0.85;
          STATE.analyser.minDecibels = -90;
          STATE.analyser.maxDecibels = -10;
          
          STATE.bufferLength = STATE.analyser.frequencyBinCount;
          STATE.dataArray = new Uint8Array(STATE.bufferLength);
          
          // Initialize bands calculation
          BANDS.calculateRanges(STATE.bufferLength);
          
          // Connect audio element to analyzer
          const source = STATE.audioContext.createMediaElementSource(DOM.audioPlayer);
          source.connect(STATE.analyser);
          STATE.analyser.connect(STATE.audioContext.destination);
          
          STATE.audioInitialized = true;
        }
        
        // Start the unified animation loop
        startAnimationLoop();
        
      } catch (error) {
        console.error("Failed to initialize audio context:", error);
      }
    }
    
    /**
     * Canvas setup and resizing
     */
    function setupCanvases() {
      // Resize both canvases to match window
      function resizeCanvases() {
        DOM.visualizationCanvas.width = window.innerWidth;
        DOM.visualizationCanvas.height = window.innerHeight;
        DOM.particleCanvas.width = window.innerWidth;
        DOM.particleCanvas.height = window.innerHeight;
      }
      
      // Initial resize
      resizeCanvases();
      
      // Add resize event listener
      window.addEventListener("resize", resizeCanvases);
    }
    
    /**
     * Frequency Analysis Functions
     */
    function groupFrequencies(dataArray) {
      if (!BANDS.ranges) {
        BANDS.calculateRanges(dataArray.length);
      }
      
      // Calculate average energy in each band
      const result = {};
      
      for (const [bandName, range] of Object.entries(BANDS.ranges)) {
        let sum = 0;
        for (let i = range.start; i < range.end; i++) {
          sum += dataArray[i];
        }
        const avgValue = sum / (range.end - range.start);
        result[bandName] = avgValue / 255; // Normalize to 0-1
      }
      
      // Get individual frequency values for each band
      result.bassValues = dataArray.slice(BANDS.ranges.bass.start, BANDS.ranges.bass.end);
      result.lowMidValues = dataArray.slice(BANDS.ranges.lowMid.start, BANDS.ranges.lowMid.end);
      result.highMidValues = dataArray.slice(BANDS.ranges.highMid.start, BANDS.ranges.highMid.end);
      result.trebleValues = dataArray.slice(BANDS.ranges.treble.start, BANDS.ranges.treble.end);
      
      return result;
    }
    
    /**
     * Helper function to check if we should show audio visualizations
     */
    function shouldShowVisualization() {
      if (!STATE.currentActive) {
        return false;
      }
      
      // Special handling for problem sections 1, 3, and 7
      if (STATE.currentActive.section && [1, 3, 7].includes(parseInt(STATE.currentActive.section)) && 
          STATE.currentActive.type === 'song' && !DOM.audioPlayer.paused) {
        return true;
      }
      
      // Only show visualizations for songs, not for audiobooks
      return !STATE.freezeMotion && STATE.audioInitialized && 
             !DOM.audioPlayer.paused && STATE.currentActive.type === 'song';
    }
    
    /**
     * Draw frequency visualization bars - Optimized
     */
    function drawAudioVisualization() {
      // Clear the canvas
      CTX.visual.clearRect(0, 0, DOM.visualizationCanvas.width, DOM.visualizationCanvas.height);
      
      // Check if we should show visualization
      if (!shouldShowVisualization()) {
        return;
      }
      
      try {
        // Get frequency data
        STATE.analyser.getByteFrequencyData(STATE.dataArray);
        
        // Group frequencies into bands
        const frequencyBands = groupFrequencies(STATE.dataArray);
        
        // Get visualization colors based on current section
        const colors = CACHED.sectionColors[STATE.currentActive ? STATE.currentActive.section : null] || 
                      CACHED.sectionColors.default;
        
        // Visualization settings
        const centerX = DOM.visualizationCanvas.width / 2;
        const centerY = DOM.visualizationCanvas.height / 2;
        const maxRadius = Math.min(DOM.visualizationCanvas.width, DOM.visualizationCanvas.height) * 0.7;
        
        // Calculate overall intensity for animation effects
        const intensity = (frequencyBands.bass * 1.5 + 
                          frequencyBands.lowMid * 1.2 + 
                          frequencyBands.highMid + 
                          frequencyBands.treble * 0.8) / 4;
        
        // Use precomputed indices
        const barCount = 64;
        const angleStep = (Math.PI * 2) / barCount;
        
        // Ensure shuffled indices are initialized
        if (CACHED.shuffledIndices.length === 0) {
          CACHED.shuffledIndices = initShuffledIndices(barCount);
        }
        
        // Draw background glow based on overall intensity
        const bgGlow = CTX.visual.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, maxRadius * 1.2
        );
        
        // Parse hex to RGB only once
        const color3Rgb = {
          r: parseInt(colors.color3.substr(1, 2), 16),
          g: parseInt(colors.color3.substr(3, 2), 16),
          b: parseInt(colors.color3.substr(5, 2), 16)
        };
        
        bgGlow.addColorStop(0, `rgba(${color3Rgb.r}, ${color3Rgb.g}, ${color3Rgb.b}, ${0.1 + intensity * 0.2})`);
        bgGlow.addColorStop(0.7, `rgba(${color3Rgb.r}, ${color3Rgb.g}, ${color3Rgb.b}, ${0.05 + intensity * 0.1})`);
        bgGlow.addColorStop(1, "rgba(0, 0, 0, 0)");
        
        CTX.visual.fillStyle = bgGlow;
        CTX.visual.beginPath();
        CTX.visual.arc(centerX, centerY, maxRadius * 1.2, 0, Math.PI * 2);
        CTX.visual.fill();
        
        // Convert hex colors to RGB once
        const color1Rgb = {
          r: parseInt(colors.color1.substr(1, 2), 16),
          g: parseInt(colors.color1.substr(3, 2), 16),
          b: parseInt(colors.color1.substr(5, 2), 16)
        };
        
        const color2Rgb = {
          r: parseInt(colors.color2.substr(1, 2), 16),
          g: parseInt(colors.color2.substr(3, 2), 16),
          b: parseInt(colors.color2.substr(5, 2), 16)
        };
        
        // ---------------------------------
        // LAYER 1: Inner Bass Visualization
        // ---------------------------------
        const bassRadius = maxRadius * 0.3;
        
        // Draw a subtle bass pulse circle
        CTX.visual.beginPath();
        CTX.visual.arc(centerX, centerY, bassRadius * (0.8 + frequencyBands.bass * 0.5), 0, Math.PI * 2);
        CTX.visual.fillStyle = `rgba(${color1Rgb.r}, ${color1Rgb.g}, ${color1Rgb.b}, ${0.1 + frequencyBands.bass * 0.3})`;
        CTX.visual.fill();
        
        // Bass frequency bars (innermost ring)
        for (let i = 0; i < barCount; i++) {
          // Use shuffled index to get better distribution
          const bassIndex = Math.floor(CACHED.shuffledIndices[i] * frequencyBands.bassValues.length / barCount);
          const value = frequencyBands.bassValues[bassIndex] / 255;
          
          const angle = i * angleStep;
          const barHeight = (0.3 + value * 0.7) * bassRadius;
          
          // Create gradient for the bars
          const gradient = CTX.visual.createLinearGradient(
            centerX, centerY,
            centerX + Math.cos(angle) * barHeight,
            centerY + Math.sin(angle) * barHeight
          );
          gradient.addColorStop(0, `rgba(${color1Rgb.r}, ${color1Rgb.g}, ${color1Rgb.b}, 0.8)`);
          gradient.addColorStop(1, `rgba(${color2Rgb.r}, ${color2Rgb.g}, ${color2Rgb.b}, 0.2)`);
          
          CTX.visual.beginPath();
          CTX.visual.moveTo(centerX, centerY);
          
          // Draw a wider arc for each bar
          const arcWidth = angleStep * 0.85;
          
          CTX.visual.arc(
            centerX, centerY,
            barHeight,
            angle - arcWidth/2,
            angle + arcWidth/2
          );
          
          CTX.visual.lineTo(centerX, centerY);
          CTX.visual.fillStyle = gradient;
          CTX.visual.fill();
        }
        
        // ---------------------------------
        // LAYER 2: Mid Frequency Visualization
        // ---------------------------------
        const midRadius = maxRadius * 0.6;
        
        // Mid frequency bars (middle ring)
        for (let i = 0; i < barCount; i++) {
          // Combine low and high mids for variety
          const midIndex = i % 2 === 0 ? 
            Math.floor(CACHED.shuffledIndices[i] * frequencyBands.lowMidValues.length / barCount) :
            Math.floor(CACHED.shuffledIndices[i] * frequencyBands.highMidValues.length / barCount);
          
          const values = i % 2 === 0 ? frequencyBands.lowMidValues : frequencyBands.highMidValues;
          let value = values[midIndex] / 255;
          
          // Enhance mid frequencies slightly for better visualization
          value = Math.pow(value, 0.8);
          
          const angle = i * angleStep + (Math.PI / barCount);
          const barStart = bassRadius * 1.1;
          const barLength = value * (midRadius - barStart);
          
          // Create gradient
          const gradient = CTX.visual.createLinearGradient(
            centerX + Math.cos(angle) * barStart,
            centerY + Math.sin(angle) * barStart,
            centerX + Math.cos(angle) * (barStart + barLength),
            centerY + Math.sin(angle) * (barStart + barLength)
          );
          gradient.addColorStop(0, `rgba(${color2Rgb.r}, ${color2Rgb.g}, ${color2Rgb.b}, 0.1)`);
          gradient.addColorStop(1, `rgba(${color2Rgb.r}, ${color2Rgb.g}, ${color2Rgb.b}, 0.7)`);
          
          const barEnd = barStart + barLength;
          const arcWidth = angleStep * 0.8;
          
          CTX.visual.beginPath();
          CTX.visual.arc(centerX, centerY, barStart, angle - arcWidth/2, angle + arcWidth/2);
          CTX.visual.arc(centerX, centerY, barEnd, angle + arcWidth/2, angle - arcWidth/2, true);
          CTX.visual.closePath();
          
          CTX.visual.fillStyle = gradient;
          CTX.visual.fill();
        }
        
        // ---------------------------------
        // LAYER 3: High Frequency Visualization
        // ---------------------------------
        const highRadius = maxRadius;
        
        // High frequency bars (outer ring)
        for (let i = 0; i < barCount; i++) {
          // Use shuffled index for treble frequencies
          const trebleIndex = Math.floor(CACHED.shuffledIndices[i] * frequencyBands.trebleValues.length / barCount);
          const value = frequencyBands.trebleValues[trebleIndex] / 255;
          
          // Enhance high frequencies more aggressively
          const enhancedValue = Math.pow(value, 0.7);
          
          const angle = i * angleStep;
          const barStart = midRadius * 1.05;
          const barLength = enhancedValue * (highRadius - barStart);
          
          // Create gradient
          const gradient = CTX.visual.createLinearGradient(
            centerX + Math.cos(angle) * barStart,
            centerY + Math.sin(angle) * barStart,
            centerX + Math.cos(angle) * (barStart + barLength),
            centerY + Math.sin(angle) * (barStart + barLength)
          );
          gradient.addColorStop(0, `rgba(${color3Rgb.r}, ${color3Rgb.g}, ${color3Rgb.b}, 0.2)`);
          gradient.addColorStop(1, `rgba(255, 255, 255, 0.8)`);
          
          const barEnd = barStart + barLength;
          const arcWidth = angleStep * 0.7;
          
          CTX.visual.beginPath();
          CTX.visual.arc(centerX, centerY, barStart, angle - arcWidth/2, angle + arcWidth/2);
          CTX.visual.arc(centerX, centerY, barEnd, angle + arcWidth/2, angle - arcWidth/2, true);
          CTX.visual.closePath();
          
          CTX.visual.fillStyle = gradient;
          CTX.visual.fill();
          
          // Add glow for prominent high frequencies
          if (enhancedValue > 0.7) {
            const glow = CTX.visual.createRadialGradient(
              centerX + Math.cos(angle) * barEnd,
              centerY + Math.sin(angle) * barEnd,
              0,
              centerX + Math.cos(angle) * barEnd,
              centerY + Math.sin(angle) * barEnd,
              10 + enhancedValue * 15
            );
            glow.addColorStop(0, `rgba(255, 255, 255, ${enhancedValue})`);
            glow.addColorStop(1, "rgba(255, 255, 255, 0)");
            
            CTX.visual.fillStyle = glow;
            CTX.visual.beginPath();
            CTX.visual.arc(
              centerX + Math.cos(angle) * barEnd,
              centerY + Math.sin(angle) * barEnd,
              10 + enhancedValue * 15,
              0, Math.PI * 2
            );
            CTX.visual.fill();
          }
        }
        
        // Add overall waveform outline that connects all frequencies
        CTX.visual.beginPath();
        CTX.visual.strokeStyle = `rgba(255, 255, 255, ${0.3 + intensity * 0.5})`;
        CTX.visual.lineWidth = 2;
        
        // Create a smoother, more balanced waveform using the shuffled indices
        for (let i = 0; i < barCount; i++) {
          const index = CACHED.shuffledIndices[i];
          const normalizedIndex = index / barCount;
          const dataIndex = Math.floor(normalizedIndex * STATE.dataArray.length);
          const value = STATE.dataArray[dataIndex] / 255;
          
          const angle = i * angleStep;
          // Use a combination of bass, mid and high frequencies for a balanced waveform
          const radius = bassRadius + (value * (highRadius - bassRadius));
          
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          if (i === 0) {
            CTX.visual.moveTo(x, y);
          } else {
            CTX.visual.lineTo(x, y);
          }
        }
        
        CTX.visual.closePath();
        CTX.visual.stroke();
      } catch (error) {
        console.error("Visualization error:", error);
      }
    }
    
    /**
     * Three.js Initialization & Animation
     */
    function initThree() {
      // Init scene
      STATE.three.scene = new THREE.Scene();
      STATE.three.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      STATE.three.renderer = new THREE.WebGLRenderer({ alpha: true });
      STATE.three.renderer.setSize(window.innerWidth, window.innerHeight);
      DOM.threeContainer.appendChild(STATE.three.renderer.domElement);
      
      STATE.three.mainGroup = new THREE.Group();
      STATE.three.scene.add(STATE.three.mainGroup);
      
      // Create the central icosahedron
      const geometry = new THREE.IcosahedronGeometry(1, 1);
      const material = new THREE.MeshStandardMaterial({ 
        color: 0x00ff00, 
        wireframe: false, 
        emissive: 0x003300 
      });
      STATE.three.polyhedron = new THREE.Mesh(geometry, material);
      STATE.three.mainGroup.add(STATE.three.polyhedron);
      
      // Add a point light
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(5, 5, 5);
      STATE.three.scene.add(pointLight);
      
      STATE.three.orbitSpheres = [];
      STATE.three.camera.position.z = 5;
      
      // Handle window resize
      window.addEventListener("resize", onThreeWindowResize, false);
    }
    
    function onThreeWindowResize() {
      STATE.three.camera.aspect = window.innerWidth / window.innerHeight;
      STATE.three.camera.updateProjectionMatrix();
      STATE.three.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function updateOrbitSpheres(newCount) {
      // Remove old spheres
      STATE.three.orbitSpheres.forEach(sphere => STATE.three.mainGroup.remove(sphere));
      STATE.three.orbitSpheres = [];
      
      // Reuse geometries and materials for better performance
      const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
      const sphereMaterial = new THREE.MeshBasicMaterial({ 
        color: STATE.three.polyhedron.material.color.getHex() 
      });
      
      for (let i = 0; i < newCount; i++) {
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial.clone());
        sphere.material.transparent = true;
        sphere.material.opacity = 0.8;
        sphere.userData.angle = i / newCount * Math.PI * 2;
        sphere.userData.distance = 2;
        sphere.position.set(
          Math.cos(sphere.userData.angle) * sphere.userData.distance,
          Math.sin(sphere.userData.angle) * sphere.userData.distance,
          0
        );
        STATE.three.orbitSpheres.push(sphere);
        STATE.three.mainGroup.add(sphere);
      }
    }
    
    function updateSceneParameters(section) {
      const newColor = CACHED.threeColors[section] || 0x00ff00;
      STATE.three.polyhedron.material.color.setHex(newColor);
      STATE.three.rotationSpeed = CACHED.rotationSpeeds[section] || 0.01;
      
      STATE.three.orbitSpheres.forEach(sphere => {
        sphere.material.color.setHex(newColor);
        sphere.material.transparent = true;
        sphere.material.opacity = 0.8;
      });
      
      updateOrbitSpheres(section);
    }
    
    /**
     * Update Three.js scene based on audio
     */
    function updateThreeScene() {
      if (STATE.freezeMotion) return;
      
      // Update Three.js scene
      if (shouldShowVisualization() && STATE.analyser) {
        // Audio-driven animation
        STATE.analyser.getByteFrequencyData(STATE.dataArray);
        
        // Calculate average frequency value
        let sum = 0;
        for (let i = 0; i < STATE.dataArray.length; i++) {
          sum += STATE.dataArray[i];
        }
        const averageFreq = sum / STATE.dataArray.length;
        const normalizedAvg = averageFreq / 255;
        
        // Modify polyhedron based on audio
        let bassAvg = 0;
        for (let i = 0; i < Math.min(8, STATE.dataArray.length); i++) {
          bassAvg += STATE.dataArray[i];
        }
        bassAvg = bassAvg / Math.min(8, STATE.dataArray.length) / 255;
        
        STATE.three.polyhedron.scale.set(
          1 + bassAvg * 0.3,
          1 + bassAvg * 0.3,
          1 + bassAvg * 0.3
        );
        
        // Speed of rotation based on mid-frequencies
        const dynamicSpeed = STATE.three.rotationSpeed * (1 + normalizedAvg * 0.5);
        STATE.three.polyhedron.rotation.x += dynamicSpeed;
        STATE.three.polyhedron.rotation.y += dynamicSpeed;
        
        // Modify orbit spheres based on frequency bands
        if (STATE.three.orbitSpheres.length > 0) {
          const bandSize = Math.floor(STATE.dataArray.length / STATE.three.orbitSpheres.length);
          
          STATE.three.orbitSpheres.forEach((sphere, i) => {
            // Get average of this frequency band
            let bandSum = 0;
            const startBand = i * bandSize;
            const endBand = startBand + bandSize;
            
            for (let j = startBand; j < endBand && j < STATE.dataArray.length; j++) {
              bandSum += STATE.dataArray[j];
            }
            
            const bandAvg = bandSum / bandSize / 255;
            
            // Update sphere properties based on its frequency band
            sphere.userData.angle += dynamicSpeed * (1 + bandAvg * 0.5);
            
            // Make orbit distance responsive to audio
            const baseDistance = 2;
            sphere.userData.distance = baseDistance * (1 + bandAvg * 0.8);
            
            // Update position with new angle and distance
            sphere.position.x = Math.cos(sphere.userData.angle) * sphere.userData.distance;
            sphere.position.y = Math.sin(sphere.userData.angle) * sphere.userData.distance;
            
            // Update size and opacity
            sphere.scale.set(
              0.7 + bandAvg * 1.5,
              0.7 + bandAvg * 1.5,
              0.7 + bandAvg * 1.5
            );
            sphere.material.opacity = 0.4 + bandAvg * 0.6;
          });
        }
      } else {
        // Basic animation when no audio is playing
        STATE.three.polyhedron.rotation.x += STATE.three.rotationSpeed;
        STATE.three.polyhedron.rotation.y += STATE.three.rotationSpeed;
        
        STATE.three.orbitSpheres.forEach(sphere => {
          sphere.userData.angle += STATE.three.rotationSpeed;
          sphere.position.x = Math.cos(sphere.userData.angle) * sphere.userData.distance;
          sphere.position.y = Math.sin(sphere.userData.angle) * sphere.userData.distance;
        });
      }
      
      // Common motion regardless of audio
      const t = Date.now() * 0.0000373; // Simplified calculation
      const circleRadiusMotion = 1.5;
      STATE.three.mainGroup.position.x = Math.cos(t) * circleRadiusMotion - 1;
      STATE.three.mainGroup.position.y = -Math.sin(t) * circleRadiusMotion;
      
      // Render scene
      STATE.three.renderer.render(STATE.three.scene, STATE.three.camera);
    }
    
    /**
     * Particle System Management
     */
    function spawnParticles(emitter, count, speedMultiplier) {
      if (!emitter) return;
      
      // Get current position from emitter
      const position = emitter.getPosition();
      const x = position.x;
      const y = position.y;
      const color = emitter.color;
      
      const now = Date.now() * 0.0008;
      const particles = STATE.particles;
      
      for (let i = 0; i < count; i++) {
        const angle = Math.cos(now) * Math.PI * 2 + Math.random() * 0.4;
        const speed = (Math.random() * 5 + 100) * speedMultiplier;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const life = Math.random() * 1 + 0.2;
        
        particles.push(new Particle(x, y, vx, vy, life, color));
      }
    }
    
    function updateParticles(time) {
      const delta = (time - STATE.lastTime) / 1000;
      STATE.lastTime = time;
      
      // Clear particle canvas
      CTX.particle.clearRect(0, 0, DOM.particleCanvas.width, DOM.particleCanvas.height);
      
      const activeEmitter = STATE.activeEmitter;
      
      if (activeEmitter) {
        STATE.spawnAccumulator += delta;
        
        // If audio is playing, make particle emission react to audio (only for songs)
        if (shouldShowVisualization() && STATE.analyser) {
          STATE.analyser.getByteFrequencyData(STATE.dataArray);
          
          // Calculate average frequency
          let sum = 0;
          for (let i = 0; i < STATE.dataArray.length; i++) {
            sum += STATE.dataArray[i];
          }
          const avgFreq = sum / STATE.dataArray.length;
          
          // More particles and faster with louder audio
          const baseInterval = 0.1;
          const speedMultiplier = 1 + (avgFreq / 255) * 1.5;
          const particleCount = Math.max(3, Math.floor(avgFreq / 255 * 15));
          
          // Batch particle creation
          while (STATE.spawnAccumulator > baseInterval) {
            spawnParticles(activeEmitter, particleCount, speedMultiplier);
            STATE.spawnAccumulator -= baseInterval;
          }
        } else {
          // Default particle behavior when no audio playing
          while (STATE.spawnAccumulator > 0.1) {
            spawnParticles(activeEmitter, 5, 1);
            STATE.spawnAccumulator -= 0.1;
          }
        }
      }
      
      // Process and draw particles - more efficient loop
      const particles = STATE.particles;
      let i = particles.length;
      
      while (i--) {
        const p = particles[i];
        // If particle is dead, remove it and continue
        if (p.update(delta)) {
          // Faster removal without splice
          particles[i] = particles[particles.length - 1];
          particles.pop();
        } else {
          p.draw(CTX.particle);
        }
      }
    }
    
    /**
     * Unified Animation Loop (combines all animations for better performance)
     */
    function animationLoop(time) {
      // Update Three.js scene
      updateThreeScene();
      
      // Update particles
      updateParticles(time);
      
      // Update audio visualization
      drawAudioVisualization();
      
      // Request next frame
      STATE.animationFrameId = requestAnimationFrame(animationLoop);
    }
    
    function startAnimationLoop() {
      if (!STATE.animationFrameId) {
        STATE.animationFrameId = requestAnimationFrame(animationLoop);
      }
    }
    
    function stopAnimationLoop() {
      if (STATE.animationFrameId) {
        cancelAnimationFrame(STATE.animationFrameId);
        STATE.animationFrameId = null;
      }
    }
    
    /**
     * Special Effects & Animations
     */
    function triggerSpecialAnimation() {
      const overlay = DOM.specialOverlay;
      overlay.style.display = "block";
      overlay.innerHTML = ""; // Clear any previous elements
      
      // Create an initial flash effect
      const flash = document.createElement("div");
      flash.style.position = "absolute";
      flash.style.width = "100%";
      flash.style.height = "100%";
      flash.style.backgroundColor = "white";
      flash.style.opacity = "0";
      overlay.appendChild(flash);
      
      // Flash sequence
      gsap.to(flash, {
        opacity: 0.7,
        duration: 2.0,
        yoyo: true,
        repeat: 1,
        onComplete: function() {
          overlay.removeChild(flash);
        }
      });
      
      // Create shine elements from each corner
      const corners = [
        { angle: 45, startX: -window.innerWidth, startY: window.innerHeight },
        { angle: -45, startX: window.innerWidth * 2, startY: window.innerHeight },
        { angle: 45, startX: window.innerWidth * 2, startY: -window.innerHeight/2 },
        { angle: -45, startX: -window.innerWidth, startY: -window.innerHeight/2 }
      ];
      
      // Create and animate each shine from different corners
      corners.forEach((corner, index) => {
        setTimeout(() => {
          // Create shine element
          const shine = document.createElement("div");
          shine.className = "shine";
          overlay.appendChild(shine);
          
          // Set initial position and rotation
          gsap.set(shine, { 
            x: corner.startX, 
            y: corner.startY, 
            opacity: 0.9,
            rotation: corner.angle
          });
          
          // Animate across the screen
          gsap.to(shine, {
            duration: 3.0, 
            x: corner.startX > 0 ? -window.innerWidth : window.innerWidth * 2,
            y: corner.startY > 0 ? -window.innerHeight/2 : window.innerHeight,
            ease: "power2.inOut",
            onComplete: function() {
              overlay.removeChild(shine);
            }
          });
        }, index * 150); // Stagger the animations
      });
      
      // Create sparkle effects
      const sparkleCount = 40;
      for (let i = 0; i < sparkleCount; i++) {
        setTimeout(() => {
          createSparkle(overlay);
        }, Math.random() * 1000);
      }
      
      // Set a timeout to hide the overlay after animations complete
      setTimeout(() => {
        gsap.to(overlay, {
          opacity: 0,
          duration: 1.5,
          delay: 2.5,
          onComplete: function() {
            overlay.style.display = "none";
            overlay.style.opacity = 1; // Reset opacity for next time
          }
        });
      }, 0);
    }
    
    function createSparkle(parent) {
      const sparkle = document.createElement("div");
      sparkle.className = "sparkle";
      
      // Random position and properties
      const x = Math.random() * window.innerWidth;
      const y = Math.random() * window.innerHeight;
      const size = 5 + Math.random() * 15;
      const hue = Math.floor(Math.random() * 360);
      const color = `hsl(${hue}, 100%, 70%)`;
      
      // Set properties
      sparkle.style.left = `${x}px`;
      sparkle.style.top = `${y}px`;
      sparkle.style.width = `${size}px`;
      sparkle.style.height = `${size}px`;
      sparkle.style.backgroundColor = color;
      
      // Add to overlay
      parent.appendChild(sparkle);
      
      // Animate with GSAP
      gsap.to(sparkle, {
        keyframes: [
          { opacity: 0, scale: 0, duration: 0 },
          { opacity: 1, scale: 1.2, duration: 0.3 },
          { opacity: 0.8, scale: 0.9, duration: 0.2 },
          { opacity: 1, scale: 1.1, duration: 0.2 },
          { opacity: 0.7, scale: 1, duration: 0.3 },
          { opacity: 0, scale: 0, duration: 0.5 }
        ],
        ease: "power1.out",
        onComplete: function() {
          parent.removeChild(sparkle);
        }
      });
    }
    
    /**
     * Helper Functions
     */
    function convertSection(section) {
      return section === 10 ? "0" : section.toString();
    }
    
    function getMediaPaths(section, type) {
      const baseSection = convertSection(section);
      let audioPath, textPath, imagePath;
      
      if (type === 'song') {
        audioPath = "audio/song" + baseSection + ".mp3";
        textPath = "text/song" + baseSection + ".txt";
        imagePath = "images/section" + baseSection + "-image.jpg";
        
        // Check for special combinations
        if (STATE.secondLastSection !== null && STATE.lastSection !== null) {
          const convSecondLast = convertSection(STATE.secondLastSection);
          const convLast = convertSection(STATE.lastSection);
          const convCurrent = baseSection;
          const combo = convSecondLast + convLast + convCurrent;
          
          if (CACHED.specialCombinations[combo]) {
            audioPath = "audio/song" + combo + ".mp3";
            textPath = "text/song" + combo + ".txt";
            imagePath = "images/section" + combo + "-image.jpg";
          }
        }
      } else {
        // Audiobook
        audioPath = "audio/audio" + baseSection + ".mp3";
        textPath = "text/audio" + baseSection + ".txt";
        imagePath = "images/section" + baseSection + "-image.jpg";
      }
      
      return { audioPath, textPath, imagePath };
    }
    
    function updateClickHistory(section) {
      STATE.secondLastSection = STATE.lastSection;
      STATE.lastSection = section;
    }
    
    function clearCurrentActive() {
      if (STATE.currentActive && STATE.currentActive.section) {
        const elem = document.getElementById("section-" + STATE.currentActive.section);
        if (elem) { elem.classList.remove("active"); }
      }
      
      DOM.audioPlayer.pause();
      DOM.audioPlayer.currentTime = 0;
    }
    
    function resetActiveState() {
      clearCurrentActive();
      STATE.currentActive = null;
      STATE.activeEmitter = null;
      STATE.freezeMotion = true;
      DOM.textContainer.innerHTML = "<p>Select a section to load the text.</p>";
      removeStyleClasses();
      document.body.classList.add('default-style');
      STATE.lastSection = null;
      STATE.secondLastSection = null;
      
      // Reset polyhedron scale
      if (STATE.three.polyhedron) {
        STATE.three.polyhedron.scale.set(1, 1, 1);
      }
      
      // Reset orbit spheres
      STATE.three.orbitSpheres.forEach(sphere => {
        sphere.userData.distance = 2;
        sphere.scale.set(1, 1, 1);
        sphere.material.opacity = 0.8;
      });
    }
    
    function removeStyleClasses() {
      document.body.classList.remove(
        'style-section-1', 'style-section-2', 'style-section-3', 'style-section-4',
        'style-section-5', 'style-section-6', 'style-section-7', 'style-section-8',
        'style-section-9', 'style-section-10'
      );
    }
    
    /**
     * Audio Playback Handlers
     */
    function handleAudioClick(section, type) {
      // If same active section clicked, toggle off
      if (STATE.currentActive && STATE.currentActive.section === section && STATE.currentActive.type === type) {
        resetActiveState();
        return;
      }
      
      // Get media paths for current click
      const { audioPath, textPath, imagePath } = getMediaPaths(section, type);
      
      // If special combination exists, trigger the animation
      if (type === 'song' && STATE.secondLastSection !== null && STATE.lastSection !== null) {
        const convSecondLast = convertSection(STATE.secondLastSection);
        const convLast = convertSection(STATE.lastSection);
        const convCurrent = convertSection(section);
        const combo = convSecondLast + convLast + convCurrent;
        
        if (CACHED.specialCombinations[combo]) {
          triggerSpecialAnimation();
        }
      }
      
      // Update click history
      updateClickHistory(section);
      
      // Clear current active state if any
      clearCurrentActive();
      
      // Set new active state
      STATE.currentActive = { section, type };
      
      const secElem = document.getElementById("section-" + section);
      if (secElem) { secElem.classList.add("active"); }
      
      // Set audio source
      DOM.audioPlayer.src = audioPath;
      
      // Force visualization initialization
      if (!STATE.audioInitialized) {
        initAudioContext();
      }
      
      // Make the visualization visible only for songs
      DOM.visualizationCanvas.style.opacity = type === 'song' ? '0.4' : '0';
      
      // Play audio with error handling
      const playPromise = DOM.audioPlayer.play();
      
      if (playPromise !== undefined) {
        playPromise.then(() => {
          // Make sure audio context is running
          if (STATE.audioContext && STATE.audioContext.state === 'suspended') {
            STATE.audioContext.resume();
          }
        }).catch(error => {
          console.error("Error playing audio:", error);
          
          // Try to recover
          if (error.name === 'NotAllowedError') {
            alert("Audio playback was blocked by your browser. Please click again to play.");
          }
        });
      }
      
      // Update UI
      DOM.centerImage.src = imagePath;
      removeStyleClasses();
      document.body.classList.add("style-section-" + section);
      updateSceneParameters(section);
      STATE.freezeMotion = false;
      
      // Update particle emitter
      STATE.activeEmitter = { 
        getPosition: function() {
          // Get updated position on each frame to account for zooming/scrolling
          const elem = document.getElementById("section-" + section);
          if (elem) {
            const rect = elem.getBoundingClientRect();
            return {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
            };
          }
          return { x: 0, y: 0 };
        },
        color: CACHED.emitterColors[section] || "255,255,0"
      };
      
      // Load text content
      fetch(textPath)
        .then(response => {
          if (!response.ok) { throw new Error("Network response was not ok"); }
          return response.text();
        })
        .then(data => { 
          DOM.textContainer.textContent = data;
        })
        .catch(error => {
          DOM.textContainer.textContent = "Error loading text.";
          console.error("Error fetching text file:", error);
        });
    }
    
    function handlePrologue() {
      if (STATE.currentActive && STATE.currentActive.prologue) {
        DOM.audioPlayer.pause();
        DOM.audioPlayer.currentTime = 0;
        STATE.currentActive = null;
        STATE.activeEmitter = null;
        STATE.freezeMotion = true;
        DOM.textContainer.innerHTML = "<p>Select a section to load the text.</p>";
        
        // Hide visualization for audiobooks
        DOM.visualizationCanvas.style.opacity = '0';
        return;
      }
      
      if (STATE.currentActive) {
        clearCurrentActive();
      }
      
      STATE.currentActive = { prologue: true, type: 'audiobook' };
      STATE.activeEmitter = null;
      STATE.freezeMotion = true;
      DOM.audioPlayer.src = "audio/audio00.mp3";
      
      // Hide visualization for audiobooks
      DOM.visualizationCanvas.style.opacity = '0';
      
      // Play audio and initialize audio context if needed
      DOM.audioPlayer.play().then(() => {
        if (!STATE.audioInitialized) {
          initAudioContext();
        } else if (STATE.audioContext && STATE.audioContext.state === 'suspended') {
          STATE.audioContext.resume();
        }
      }).catch(e => {
        console.error("Error starting prologue audio:", e);
      });
      
      // Update UI
      DOM.centerImage.src = "images/default-image.jpg";
      DOM.textContainer.innerHTML = "";
      
      fetch("text/audio00.txt")
        .then(response => {
          if (!response.ok) { throw new Error("Network response was not ok"); }
          return response.text();
        })
        .then(data => { 
          DOM.textContainer.textContent = data;
        })
        .catch(error => {
          DOM.textContainer.textContent = "Error loading prologue text.";
          console.error("Error fetching prologue text:", error);
        });
    }
    
    /**
     * UI Controls
     */
    function toggleAnimations() {
      STATE.freezeMotion = !STATE.freezeMotion;
      DOM.toggleButton.textContent = STATE.freezeMotion ? "Anim On" : "Anim Off";
      
      // Reset visualizations when animations are off
      if (STATE.freezeMotion) {
        // Hide visualization
        DOM.visualizationCanvas.style.opacity = '0';
        
        // Reset 3D objects
        if (STATE.three.polyhedron) {
          STATE.three.polyhedron.scale.set(1, 1, 1);
        }
        
        STATE.three.orbitSpheres.forEach(sphere => {
          sphere.userData.distance = 2;
          sphere.position.x = Math.cos(sphere.userData.angle) * sphere.userData.distance;
          sphere.position.y = Math.sin(sphere.userData.angle) * sphere.userData.distance;
          sphere.scale.set(1, 1, 1);
          sphere.material.opacity = 0.8;
        });
      } else {
        // Show visualization when animations are on (but only for songs)
        if (STATE.currentActive && STATE.currentActive.type === 'song') {
          DOM.visualizationCanvas.style.opacity = '0.4';
        }
      }
    }
    
    /**
     * Event Listeners
     */
    function setupEventListeners() {
      // Handle audio end
      DOM.audioPlayer.addEventListener('ended', function() {
        if (STATE.currentActive && STATE.currentActive.section) {
          const elem = document.getElementById("section-" + STATE.currentActive.section);
          if (elem) { elem.classList.remove("active"); }
        }
        
        STATE.currentActive = null;
        STATE.activeEmitter = null;
        STATE.freezeMotion = true;
        DOM.centerImage.src = "images/default-image.jpg";
        DOM.textContainer.innerHTML = "<p>Select a section to load the text.</p>";
        removeStyleClasses();
        document.body.classList.add('default-style');
        
        // Hide visualization when audio ends
        DOM.visualizationCanvas.style.opacity = '0';
        
        // Reset polyhedron scale
        if (STATE.three.polyhedron) {
          STATE.three.polyhedron.scale.set(1, 1, 1);
        }
      });
      
      // Key press handler for visualization style cycling
      window.addEventListener('keydown', function(e) {
        // Press 'V' key to cycle visualization styles
        if (e.key === 'v' || e.key === 'V') {
          STATE.currentVisualizationStyle = (STATE.currentVisualizationStyle % 3) + 1;
          console.log(`Switched to visualization style ${STATE.currentVisualizationStyle}`);
        }
      });
      
      // Prevent right-click on audio player
      DOM.audioPlayer.addEventListener("contextmenu", function(e) {
        e.preventDefault();
      });
      
      // Detect when audio player is playing specific sections
      DOM.audioPlayer.addEventListener('play', () => {
        if (STATE.currentActive && [1, 3, 7].includes(parseInt(STATE.currentActive.section))) {
          // Force-set canvas opacity if it's a song
          if (STATE.currentActive.type === 'song') {
            DOM.visualizationCanvas.style.opacity = '0.4';
          }
        }
      });
    }
    
    /**
     * Initialization
     */
    function init() {
      // Initialize shuffled indices
      CACHED.shuffledIndices = initShuffledIndices(64);
      
      // Initialize canvases
      setupCanvases();
      
      // Setup Three.js
      initThree();
      
      // Setup event listeners
      setupEventListeners();
      
      // Start the animation loop
      startAnimationLoop();
    }
    
    // Initialize when DOM is ready
    window.addEventListener('DOMContentLoaded', init);
    
    // Public API
    return {
      handleAudioClick,
      handlePrologue,
      toggleAnimations
    };
  })();
  </script>
</body>
</html>